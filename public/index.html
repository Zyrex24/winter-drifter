<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Winter Drifter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #E0CCFF;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas when playing */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .screen {
            background: rgba(46, 26, 71, 0.9);
            padding: 2rem;
            border-radius: 20px;
            border: 2px solid #FFC2C7;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 194, 199, 0.2);
            max-width: 90%;
            width: 400px;
            transition: opacity 0.3s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            color: #FFC2C7;
            text-shadow: 0 0 10px rgba(255, 194, 199, 0.5);
            font-weight: 300;
            letter-spacing: 2px;
        }

        p {
            margin-bottom: 1.5rem;
            color: #BDB2CF;
            font-style: italic;
        }

        .input-group {
            margin-bottom: 1.5rem;
            text-align: left;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #A2D2FF;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4A4E69;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            outline: none;
        }
        input[type="text"]:focus {
            border-color: #FFC2C7;
        }

        button {
            background: #4A4E69;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 5px;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button.primary {
            background: linear-gradient(135deg, #FFC2C7, #A2D2FF);
            color: #2E1A47;
            width: 100%;
            margin-top: 1rem;
            font-size: 1.2rem;
        }

        .custom-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 10px;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            display: inline-block;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }
        
        #hud.visible {
            display: block;
        }

        .hud-item {
            position: absolute;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top)); /* Safe area for notches */
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }

        /* Reposition HUD elements for better mobile visibility */
        #hud-hearts { 
            top: 10px; 
            left: 10px; 
            font-size: 2rem; 
            color: #FFC2C7; 
        }
        
        /* Note: Name and Score are now drawn on canvas attached to player, 
           so we removed them from fixed HUD corners to avoid clutter/overlap,
           but I'll keep the Hearts in the top left corner. */

        #game-over-screen h2 {
            font-size: 2rem;
            color: #FFC2C7;
            margin-bottom: 10px;
        }
        #final-score {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
            color: white;
        }

        #pet-label {
            min-width: 80px;
            text-align: right;
            margin-right: 10px;
            font-weight: bold;
            color: #A2D2FF;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <h1>Winter Drifter</h1>
            <p>Ascend through the gentle storm.</p>
            
            <div class="input-group">
                <label>Drifter Name</label>
                <input type="text" id="player-name-input" value="Player" maxlength="10">
            </div>

            <div class="custom-row">
                <span>Hood Color</span>
                <div style="display:flex; align-items:center; gap:10px;">
                    <div id="hood-preview" class="color-preview" style="background-color: #F8F9FA;"></div>
                    <button id="cycle-color-btn" style="padding: 5px 15px; font-size:0.8rem;">Cycle</button>
                </div>
            </div>

            <div class="custom-row">
                <span>Companion</span>
                <div style="display:flex; align-items:center;">
                    <span id="pet-label">None</span>
                    <button id="cycle-pet-btn" style="padding: 5px 15px; font-size:0.8rem;">Cycle</button>
                </div>
            </div>

            <button id="start-btn" class="primary">Begin Drift</button>
            <div id="leaderboard-link" style="margin-top:15px; cursor:pointer; color:#A2D2FF; text-decoration:underline;">View Leaderboard</div>
        </div>

        <!-- Leaderboard Screen -->
        <div id="leaderboard-screen" class="screen hidden">
            <h2>Leaderboard</h2>
            <div id="leaderboard-list" style="max-height: 200px; overflow-y: auto; text-align: left; margin-bottom: 20px;">
                <p>Loading...</p>
            </div>
            <button id="back-from-lb-btn" class="primary">Back</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <h2>Drift Ended</h2>
            <p>You found peace in the storm.</p>
            <div id="final-score">0</div>
            <button id="restart-btn" class="primary">Drift Again</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <!-- Only Hearts remain fixed in UI, name/score are on player -->
        <div id="hud-hearts" class="hud-item">♥♥♥</div>
    </div>

    <script>
        /** 
         * WINTER DRIFTER
         * A single-file HTML5 Canvas game.
         */

        // --- Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const hud = document.getElementById('hud');
        const hudHearts = document.getElementById('hud-hearts');
        const nameInput = document.getElementById('player-name-input');
        
        const colorBtn = document.getElementById('cycle-color-btn');
        const hoodPreview = document.getElementById('hood-preview');
        
        const petBtn = document.getElementById('cycle-pet-btn');
        const petLabel = document.getElementById('pet-label');

        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const finalScoreEl = document.getElementById('final-score');
        
        const lbLink = document.getElementById('leaderboard-link');
        const lbList = document.getElementById('leaderboard-list');
        const backLbBtn = document.getElementById('back-from-lb-btn');

        // Colors
        const COLORS = {
            hoods: [
                { name: 'White', hex: '#F8F9FA' },
                { name: 'Pink', hex: '#FFC2C7' },
                { name: 'Black', hex: '#2B2D42' },
                { name: 'Blue', hex: '#8ECAE6' }
            ],
            pets: [
                { id: 'none', name: 'None' },
                { id: 'cat', name: 'Void Cat' },
                { id: 'bunny', name: 'Snow Bunny' },
                { id: 'bat', name: 'Tiny Bat' }
            ],
            bgTop: '#2E1A47',
            bgBottom: '#000000',
            cloud: '#4A4E69',
            light: '#FEE440',
            skin: '#FFE5D9'
        };

        // Game State
        let state = {
            status: 'START', // START, PLAYING, GAMEOVER
            width: 0,
            height: 0,
            score: 0,
            hearts: 3,
            frameCount: 0,
            gameSpeed: 2,
            shake: 0,
            playerName: "Player"
        };

        let player = {
            x: 0,
            y: 0,
            targetX: 0,
            radius: 20,
            hoodIndex: 0,
            petIndex: 1, // Default to Cat
            blinkTimer: 0
        };

        let entities = {
            snow: [],
            clouds: [],
            lights: [],
            particles: []
        };

        // --- Setup & Input ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            state.width = canvas.width;
            state.height = canvas.height;
            if (state.status === 'START') {
                player.x = state.width / 2;
                player.targetX = state.width / 2;
                player.y = state.height * 0.75;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // Mouse / Touch
        function handleInput(x) {
            player.targetX = x;
        }

        window.addEventListener('mousemove', (e) => {
            if (state.status === 'PLAYING') handleInput(e.clientX);
        });
        window.addEventListener('touchmove', (e) => {
            if (state.status === 'PLAYING') {
                e.preventDefault();
                handleInput(e.touches[0].clientX);
            }
        }, { passive: false });
        window.addEventListener('touchstart', (e) => {
             if (state.status === 'PLAYING') {
                handleInput(e.touches[0].clientX);
             }
        });

        // Customization Logic
        colorBtn.addEventListener('click', () => {
            player.hoodIndex = (player.hoodIndex + 1) % COLORS.hoods.length;
            hoodPreview.style.backgroundColor = COLORS.hoods[player.hoodIndex].hex;
        });

        // Initialize Pet Label
        petLabel.textContent = COLORS.pets[player.petIndex].name;
        
        petBtn.addEventListener('click', () => {
            player.petIndex = (player.petIndex + 1) % COLORS.pets.length;
            petLabel.textContent = COLORS.pets[player.petIndex].name;
        });

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', resetGame);
        
        lbLink.addEventListener('click', showLeaderboard);
        backLbBtn.addEventListener('click', () => {
            leaderboardScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        // --- Leaderboard Logic ---
        async function showLeaderboard() {
            startScreen.classList.add('hidden');
            leaderboardScreen.classList.remove('hidden');
            lbList.innerHTML = '<p>Loading...</p>';
            
            try {
                const res = await fetch('/api/leaderboard');
                if (!res.ok) throw new Error('Failed to fetch');
                const data = await res.json();
                
                if (data.length === 0) {
                    lbList.innerHTML = '<p>No drifters yet.</p>';
                    return;
                }
                
                let html = '<table style="width:100%; font-size:0.9rem;">';
                data.forEach((entry, i) => {
                    // Clean name (remove timestamp suffix if exists)
                    let display = entry.name.split(':')[0];
                    html += `<tr>
                        <td style="color:#A2D2FF;">${i+1}. ${display}</td>
                        <td style="text-align:right; color:#FFC2C7;">${Math.floor(entry.score)}</td>
                    </tr>`;
                });
                html += '</table>';
                lbList.innerHTML = html;
            } catch (err) {
                console.error(err);
                lbList.innerHTML = '<p style="color:red">Failed to load scores.</p>';
            }
        }

        async function submitScore(score) {
            const name = state.playerName;
            try {
                await fetch('/api/leaderboard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score })
                });
            } catch (err) {
                console.error("Score submission failed", err);
            }
        }

        // --- Game Logic ---

        function initEntities() {
            entities.snow = [];
            entities.clouds = [];
            entities.lights = [];
            entities.particles = [];
            
            // Pre-warm snow
            for (let i = 0; i < 100; i++) {
                entities.snow.push(createSnowflake(true));
            }
        }

        function startGame() {
            state.playerName = nameInput.value.trim() || "Player";
            // Pet and Hood are already set in player object via UI
            
            // Update HUD
            state.score = 0;
            state.hearts = 3;
            state.gameSpeed = 2;
            state.frameCount = 0;
            player.blinkTimer = 0;
            
            // Reset position
            player.x = state.width / 2;
            player.targetX = state.width / 2;
            player.y = state.height * 0.75;

            initEntities();

            // UI Transition
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.add('visible');
            
            state.status = 'PLAYING';
            loop();
        }

        function resetGame() {
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('visible');
            state.status = 'START';
        }

        function gameOver() {
            state.status = 'GAMEOVER';
            finalScoreEl.textContent = Math.floor(state.score);
            hud.classList.remove('visible');
            gameOverScreen.classList.remove('hidden');
            
            // Submit Score
            if (state.score > 0) {
                submitScore(Math.floor(state.score));
            }
        }

        function createSnowflake(randomY = false) {
            const depth = Math.random(); // 0 to 1
            return {
                x: Math.random() * state.width,
                y: randomY ? Math.random() * state.height : -10,
                z: depth, // determines speed and size (foreground vs background)
                radius: Math.random() * 2 + 1,
                speed: 1 + depth * 3,
                sway: Math.random() * 0.05
            };
        }

        function createCloud() {
            const size = 40 + Math.random() * 40;
            return {
                x: Math.random() * state.width,
                y: -100,
                radius: size, // hit box
                speed: state.gameSpeed,
                type: 'cloud',
                circles: [ // Visuals
                    {dx: 0, dy: 0, r: size},
                    {dx: -size*0.5, dy: size*0.2, r: size*0.7},
                    {dx: size*0.5, dy: size*0.2, r: size*0.7},
                    {dx: 0, dy: -size*0.3, r: size*0.8}
                ]
            };
        }

        function createLight() {
            return {
                x: Math.random() * state.width,
                y: -50,
                radius: 15,
                speed: state.gameSpeed,
                type: 'light',
                pulse: 0
            };
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 10; i++) {
                entities.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 1.0,
                    color: color
                });
            }
        }

        function update() {
            // Increase speed slightly
            state.gameSpeed += 0.0005;
            state.score += 0.05; // Passive score for survival
            state.frameCount++;

            // Shake decay
            if (state.shake > 0) state.shake *= 0.9;
            if (state.shake < 0.5) state.shake = 0;

            // Player Physics (Floaty)
            player.x += (player.targetX - player.x) * 0.08;
            
            // Constrain
            if (player.x < player.radius) player.x = player.radius;
            if (player.x > state.width - player.radius) player.x = state.width - player.radius;

            // Blink Timer
            if (player.blinkTimer > 0) player.blinkTimer--;

            // --- Spawning ---
            // Snow
            if (entities.snow.length < 150) {
                 entities.snow.push(createSnowflake());
            }

            // Clouds
            if (state.frameCount % 120 === 0) { // Every ~2 seconds
                entities.clouds.push(createCloud());
            }

            // Lights
            if (state.frameCount % 180 === 0) { // Every ~3 seconds
                entities.lights.push(createLight());
            }

            // --- Entity Updates ---

            // Snow
            entities.snow.forEach(s => {
                s.y += s.speed;
                s.x += Math.sin(state.frameCount * s.sway) * 0.5;
                if (s.y > state.height) {
                    s.y = -10;
                    s.x = Math.random() * state.width;
                }
            });

            // Clouds
            for (let i = entities.clouds.length - 1; i >= 0; i--) {
                let c = entities.clouds[i];
                c.y += c.speed;

                if (player.blinkTimer === 0) {
                    const dist = Math.hypot(player.x - c.x, player.y - c.y);
                    if (dist < c.radius + player.radius) {
                        state.hearts--;
                        player.blinkTimer = 60; 
                        state.shake = 10;
                        createExplosion(player.x, player.y, '#FFC2C7');
                        if (state.hearts <= 0) {
                            gameOver();
                            return;
                        }
                    }
                }

                if (c.y > state.height + 100) entities.clouds.splice(i, 1);
            }

            // Lights
            for (let i = entities.lights.length - 1; i >= 0; i--) {
                let l = entities.lights[i];
                l.y += l.speed;
                l.pulse += 0.1;

                const dist = Math.hypot(player.x - l.x, player.y - l.y);
                if (dist < l.radius + player.radius + 10) { 
                    entities.lights.splice(i, 1);
                    state.score += 50;
                    createExplosion(l.x, l.y, '#FEE440');
                    continue;
                }

                if (l.y > state.height + 50) entities.lights.splice(i, 1);
            }

            // Particles
            for (let i = entities.particles.length - 1; i >= 0; i--) {
                let p = entities.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) entities.particles.splice(i, 1);
            }

            // Update HUD Hearts only
            hudHearts.textContent = "♥".repeat(state.hearts);
        }

        // --- Drawing ---

        function draw() {
            // Screen Shake
            let dx = (Math.random() - 0.5) * state.shake;
            let dy = (Math.random() - 0.5) * state.shake;

            ctx.save();
            ctx.translate(dx, dy);

            // Background
            let grad = ctx.createLinearGradient(0, 0, 0, state.height);
            grad.addColorStop(0, COLORS.bgTop);
            grad.addColorStop(1, COLORS.bgBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(-dx, -dy, state.width + Math.abs(dx)*2, state.height + Math.abs(dy)*2);

            // Background Snow (Low Z)
            drawSnow(0, 0.5);

            // Lights
            entities.lights.forEach(l => {
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = COLORS.light;
                ctx.fillStyle = COLORS.light;
                ctx.beginPath();
                ctx.arc(l.x, l.y, l.radius + Math.sin(l.pulse)*2, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(l.x, l.y, l.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Clouds
            entities.clouds.forEach(c => {
                ctx.fillStyle = COLORS.cloud;
                c.circles.forEach(circ => {
                    ctx.beginPath();
                    ctx.arc(c.x + circ.dx, c.y + circ.dy, circ.r, 0, Math.PI*2);
                    ctx.fill();
                });
            });

            // Player
            if (state.status !== 'GAMEOVER' || state.hearts > 0) {
                if (Math.floor(player.blinkTimer / 4) % 2 === 0) { 
                    drawPlayer();
                }
            }

            // Foreground Snow (High Z)
            drawSnow(0.5, 1.0);

            // Particles
            entities.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            ctx.restore();
        }

        function drawSnow(minZ, maxZ) {
            ctx.fillStyle = 'white';
            entities.snow.forEach(s => {
                if (s.z >= minZ && s.z < maxZ) {
                    ctx.globalAlpha = s.z * 0.8;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawPlayer() {
            const px = player.x;
            const py = player.y;
            const hoodColor = COLORS.hoods[player.hoodIndex].hex;

            ctx.save();
            ctx.translate(px, py);

            // Tilt based on movement
            const tilt = (player.targetX - player.x) * 0.05;
            ctx.rotate(tilt * Math.PI / 180);

            // Umbrella Stick
            ctx.strokeStyle = '#4A4E69'; // Grey wood/metal
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(0, 30);
            ctx.stroke();
            
            // Umbrella Handle (Hook)
            ctx.beginPath();
            ctx.arc(-5, 30, 5, 0, Math.PI, false);
            ctx.stroke();

            // Body (A small cloak shape)
            ctx.fillStyle = hoodColor;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-15, 25);
            ctx.quadraticCurveTo(0, 30, 15, 25);
            ctx.lineTo(0, -15);
            ctx.fill();

            // Head/Hood
            ctx.beginPath();
            ctx.arc(0, -15, 18, 0, Math.PI*2); // Big head
            ctx.fill();

            // Face (Shadow inside hood)
            ctx.fillStyle = '#2E1A47'; // Dark purple shadow
            ctx.beginPath();
            ctx.arc(0, -12, 10, 0, Math.PI*2);
            ctx.fill();
            
            // Eyes (Glowing faint)
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(-3, -12, 2, 0, Math.PI*2);
            ctx.arc(3, -12, 2, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Companion
            drawCompanion();

            // Umbrella Top (Drawn Last)
            ctx.fillStyle = '#2E1A47';
            ctx.beginPath();
            ctx.arc(0, -35, 45, Math.PI, 0); 
            ctx.fill();
            
            // Umbrella Shine
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, -35, 40, Math.PI, 0);
            ctx.stroke();

            // 1. Attached Score (Below Character)
            ctx.save();
            ctx.font = "bold 14px 'Segoe UI', sans-serif";
            ctx.fillStyle = "#FFC2C7";
            ctx.textAlign = "center";
            ctx.fillText(Math.floor(state.score), 0, 50);
            ctx.restore();

            // 2. Attached Name (Below Score)
            ctx.save();
            ctx.font = "bold 16px 'Segoe UI', sans-serif";
            ctx.fillStyle = "#A2D2FF";
            ctx.textAlign = "center";
            ctx.shadowBlur = 4;
            ctx.shadowColor = "rgba(0,0,0,0.8)";
            ctx.fillText(state.playerName, 0, 75);
            ctx.restore();

            ctx.restore();
        }

        function drawCompanion() {
            const petId = COLORS.pets[player.petIndex].id;
            if (petId === 'none') return;

            // Position: Sitting on left shoulder (which is -x)
            // Save context for local pet transformations
            ctx.save();
            ctx.translate(-18, -18); // Base shoulder position

            if (petId === 'cat') {
                ctx.fillStyle = '#111'; 
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 3, 6, 8, -0.2, 0, Math.PI*2);
                ctx.fill();
                // Head
                ctx.beginPath();
                ctx.arc(0, -4, 5, 0, Math.PI*2);
                ctx.fill();
                // Ears
                ctx.beginPath(); ctx.moveTo(-3, -6); ctx.lineTo(-4, -10); ctx.lineTo(0, -7); ctx.fill();
                ctx.beginPath(); ctx.moveTo(3, -6); ctx.lineTo(4, -10); ctx.lineTo(0, -7); ctx.fill();
                // Eyes
                ctx.fillStyle = '#FFD700'; 
                ctx.fillRect(-2, -5, 1, 1);
                ctx.fillRect(1, -5, 1, 1);

            } else if (petId === 'bunny') {
                ctx.fillStyle = '#FFF'; 
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 3, 6, 7, -0.1, 0, Math.PI*2);
                ctx.fill();
                // Head
                ctx.beginPath();
                ctx.arc(0, -4, 5, 0, Math.PI*2);
                ctx.fill();
                // Ears (Long)
                ctx.beginPath();
                ctx.ellipse(-2, -10, 2, 6, -0.2, 0, Math.PI*2);
                ctx.ellipse(2, -10, 2, 6, 0.2, 0, Math.PI*2);
                ctx.fill();
                // Eyes (Red/Pink)
                ctx.fillStyle = '#FFC2C7'; 
                ctx.fillRect(-2, -5, 1, 1);
                ctx.fillRect(1, -5, 1, 1);

            } else if (petId === 'bat') {
                // Flying slightly near shoulder? Or perching upside down? 
                // Let's make it perch.
                ctx.fillStyle = '#4A4E69'; 
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 3, 5, 6, 0, 0, Math.PI*2);
                ctx.fill();
                // Head
                ctx.beginPath();
                ctx.arc(0, -3, 4, 0, Math.PI*2);
                ctx.fill();
                // Wings (Folded)
                ctx.fillStyle = '#2E1A47';
                ctx.beginPath();
                ctx.ellipse(-5, 4, 3, 6, 0.2, 0, Math.PI*2); // Left wing
                ctx.ellipse(5, 4, 3, 6, -0.2, 0, Math.PI*2); // Right wing
                ctx.fill();
                // Ears
                ctx.fillStyle = '#4A4E69';
                ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-3, -9); ctx.lineTo(0, -6); ctx.fill();
                ctx.beginPath(); ctx.moveTo(2, -5); ctx.lineTo(3, -9); ctx.lineTo(0, -6); ctx.fill();
                // Eyes
                ctx.fillStyle = '#E0CCFF'; 
                ctx.fillRect(-2, -4, 1, 1);
                ctx.fillRect(1, -4, 1, 1);
            }

            ctx.restore();
        }

        // --- Loop ---
        function loop() {
            if (state.status === 'PLAYING') {
                update();
                draw();
                requestAnimationFrame(loop);
            } else if (state.status === 'START') {
                // Static background effect
                state.frameCount++;
                draw(); // Draw background only essentially
                requestAnimationFrame(loop);
            }
        }

        // Start animation frame for background effect on start screen
        initEntities();
        loop();

    </script>
</body>
</html>